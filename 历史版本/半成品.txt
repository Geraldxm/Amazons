/*

AB剪枝+估值函数，估值函数用了五个参数
估值函数的系数是先验的，需要调整
搜索层数动态

更改UCB值算法，应用极大极小思想
调整C，按照turnID数量变化


// m的计算，代表最终的灵活度
// c2的计算，代表King走法的地理优势
// c1的计算，代表Queen走法的地理优势
// t1的计算，代表Queen走法对空格的控制权
// t2的计算，代表King走法对空格的控制权

//加入蒙特卡洛搜索树，调试中

*/

#include <iostream>
#include <string>
#include <cstdlib>
#include <ctime>
#include <iomanip>
#include <cstring>
#include <vector>
#include <algorithm>
#include <math.h>
#include <queue>

#define GRIDSIZE 8
#define OBSTACLE 2
#define judge_black 0
#define judge_white 1
#define grid_black 1
#define grid_white -1
#define INFINITE 0x3f3f3f3f
#define WIN 1
#define LOSE 0

// 用于输出参数
//  #define PARA
// 用于输出一些函数内部使用时间
// #define DEBUG
// 用于控制时间
#define TIME_CONTROL
#ifdef TIME_CONTROL
// 时间控制用的一些参数
double threshold = 0.95 * (double)CLOCKS_PER_SEC; // 限界时间
int start_time;
int current_time;
int out_time;
double loop_out_time;
double MCTS_time = 0.85 * (double)CLOCKS_PER_SEC;
#endif


using namespace std;
bool time_out = false;
int A_SEC = 1.00 * (double)CLOCKS_PER_SEC; // 一秒，便于调试
double maxRate = -1;                       // MCTS的最大胜率
double visitS = 0;                         // MCTS最大胜率的访问次数
inline double calculate();
inline vector<pair<int, int>> enclose(int color);
double maping(double value);


int all = 0;
int ten = 0;
int a0 = 0, a1 = 0, a2 = 0, a3 = 0, a4 = 0, a5 = 0, a6 = 0, a7 = 0, a8 = 0, a9 = 0, a10 = 0;






double f1[32] = { 0.0000, 0.1080, 0.1080, 0.1235, 0.1332, 0.1400,
				 0.1468, 0.1565, 0.1720, 0.1949, 0.2217,
				 0.2476, 0.2680, 0.2800, 0.2884, 0.3000,
				 0.3208, 0.3535, 0.4000, 0.4613, 0.5350,
				 0.6181, 0.7075, 0.8000, 1.0000, 1.0000,
				 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000 };
double f2[32] = { 1.0000, 0.3940, 0.3940, 0.3826, 0.3753, 0.3700,
				 0.3647, 0.3574, 0.3460, 0.3294, 0.3098,
				 0.2903, 0.2740, 0.2631, 0.2559, 0.2500,
				 0.2430, 0.2334, 0.2200, 0.2020, 0.1800,
				 0.1550, 0.1280, 0.1000, 0.0000, 0.0000,
				 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 };
double f3[32] = { 0.0000, 0.1160, 0.1160, 0.1224, 0.1267, 0.1300,
				 0.1333, 0.1376, 0.1440, 0.1531, 0.1640,
				 0.1754, 0.1860, 0.1944, 0.1995, 0.2000,
				 0.1950, 0.1849, 0.1700, 0.1510, 0.1287,
				 0.1038, 0.0773, 0.0500, 0.0000, 0.0000,
				 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 };
double f4[32] = { 0.0000, 0.1160, 0.1160, 0.1224, 0.1267, 0.1300,
				 0.1333, 0.1376, 0.1440, 0.1531, 0.1640,
				 0.1754, 0.1860, 0.1944, 0.1995, 0.2000,
				 0.1950, 0.1849, 0.1700, 0.1510, 0.1287,
				 0.1038, 0.0773, 0.0500, 0.0000, 0.0000,
				 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 };
double f5[32] = { 0.0000, 0.2300, 0.2300, 0.2159, 0.2067, 0.2000,
				 0.1933, 0.1841, 0.1700, 0.1496, 0.1254,
				 0.1010, 0.0800, 0.0652, 0.0557, 0.0500,
				 0.0464, 0.0436, 0.0400, 0.0346, 0.0274,
				 0.0190, 0.0097, 0.0000, 0.0000, 0.0000,
				 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 };

class Pos // 用于保存某个状态下的所有可能走法
{
public:
	int beginPos[3000][2] = { 0 }, possiblePos[3000][2] = { 0 }, obstaclePos[3000][2] = { 0 };
	int number = -1;
};

class Coor // 用于队列处理的结构体
{
public:
	int x = -1;
	int y = -1;
	int val = 0;
	Coor(int x, int y, int val)
	{
		this->x = x;
		this->y = y;
		this->val = val;
	}
};

// 用于保存一个走法
class Move
{
public:
	int x = -1, y = -1;
	int xx = -1, yy = -1;
	int xxx = -1, yyy = -1;
	int color = 0;
	Move() {};
	Move(int x, int y, int xx, int yy, int xxx, int yyy, int color)
	{
		this->x = x;
		this->y = y;
		this->xx = xx;
		this->yy = yy;
		this->xxx = xxx;
		this->yyy = yyy;
		this->color = color;
	}
};

inline int RandomNumber(int l, int r);



class treeNode
{
public:
	// 每个结点保存如何从上一步（父亲节点）走到当前步（当前节点），而不是保存棋盘状态
	Move move;
	treeNode* father = nullptr;                              // 保存父亲节点指针，便于回溯
	Pos pos;                                                 // 用于保存此结点，能走的走法总数
	treeNode* child[3000] = { nullptr };				     // 保存孩子节点的指针，和pos.number结合使用
	vector<treeNode*> selected_ch;		                    // 保存已选孩子的节点的指针
	//double win = 0;                                             // 胜利的次数
	int visit = 0;                                           // 访问次数
	double win_v = 0;                                        //胜率,以curBotcolor视角
	double UCB = INFINITE; // UCB值
	int color = 0;
	double* heap_value = nullptr;
	int* heap_ptr = nullptr;
	int depth = 0;
	//double Sort;
};

treeNode* root;

/*bool cmp(treeNode* a, treeNode* b)
{
	return a->Sort > b->Sort;
}*/

int N = 0;       // 蒙特卡洛搜索树用的参数，N表示总模拟次数
int C = 2; // UCB值 sC

int turnID;                             // 当前轮次
int currBotColor;                       // 本方所执子颜色（1为黑，-1为白，棋盘状态亦同）
vector<pair<int, int>> blackInfo;       // 记录黑子的x和y
vector<pair<int, int>> whiteInfo;       // 记录白子的x和y
vector<pair<int, int>> arrowInfo;       // 记录箭的x和y
int gridInfo[GRIDSIZE][GRIDSIZE] = { 0 }; // 先x后y，记录棋盘状态
int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 };
int dy[] = { -1, 0, 1, -1, 1, -1, 0, 1 };
double mobility[GRIDSIZE][GRIDSIZE] = { 0 }; // 各个空格的灵活度
double D2[2][8][8] = { 0 };
double D1[2][8][8] = { 0 }; // 0 我的值  1 对方的值
int beginPos[3000][2], possiblePos[3000][2], obstaclePos[3000][2];
int startX, startY, resultX, resultY, obstacleX, obstacleY;

inline Pos Choices(int color);
inline void Clear(int x0, int y0, int x1, int y1, int x2, int y2, int color);
inline void MCTS_createHeap(treeNode* p);
Pos enmoveable_Choices(int color, vector<pair<int, int>> Info);
// 判断是否在棋盘内
inline bool inMap(int x, int y)
{
	if (x < 0 || x >= GRIDSIZE || y < 0 || y >= GRIDSIZE)
		return false;
	return true;
}

int maxdeep = 0;
// 在坐标处落子，检查是否合法或模拟落子
bool ProcStep(int x0, int y0, int x1, int y1, int x2, int y2, int color, bool check_only)
{
	if ((!inMap(x0, y0)) || (!inMap(x1, y1)) || (!inMap(x2, y2))) // 0或1或2不在棋盘内
	{
		return false;
	}
	if (gridInfo[x0][y0] != color || gridInfo[x1][y1] != 0) // 如果原来位置没有该颜色的子，或者目标位置有子
	{
		return false;
	}
	if ((gridInfo[x2][y2] != 0) && !(x2 == x0 && y2 == y0)) // 放障碍位置有子并且该子不为原位置
	{
		return false;
	}
	if (!check_only) // 只检查就不落子
	{
		gridInfo[x0][y0] = 0;
		gridInfo[x1][y1] = color;
		gridInfo[x2][y2] = OBSTACLE;
	}
	return true;
}

inline void NoCheckStep(int x0, int y0, int x1, int y1, int x2, int y2, int color)
{
	gridInfo[x0][y0] = 0;
	gridInfo[x1][y1] = color;
	gridInfo[x2][y2] = OBSTACLE;
	return;
}

// 扫描棋盘，记录当前子的位置，保存到Info数组中
inline void scan()
{
	blackInfo.clear();
	whiteInfo.clear();
	arrowInfo.clear();
	for (int i = 0; i < GRIDSIZE; i++)
		for (int j = 0; j < GRIDSIZE; j++)
		{
			int address = gridInfo[i][j];
			if (!address)
				continue;
			else if (address == grid_black)
				blackInfo.push_back(make_pair(i, j));
			else if (address == grid_white)
				whiteInfo.push_back(make_pair(i, j));
			else if (address == OBSTACLE)
				arrowInfo.push_back(make_pair(i, j));
		}
}

/***************************蒙特卡洛搜索树所用的一些函数************************************************************/

inline int RandomNumber(int l, int r)
{
	// 错误状态
	if (l > r)
		return INFINITE;
	// 返回一个l到r之间的随机整数
	srand(time(nullptr));
	return rand() % (r - l + 1) + l;
}

inline void heapify(double arr[], int ptr[], int n, int i)
{
	int largest = i;
	int left = 2 * i + 1;
	int right = 2 * i + 2;

	if (left < n && arr[left] > arr[largest])
		largest = left;

	if (right < n && arr[right] > arr[largest])
		largest = right;

	if (largest != i)
	{
		swap(arr[i], arr[largest]);
		swap(ptr[i], ptr[largest]);
		heapify(arr, ptr, n, largest);
	}
	return;
}

// 调用heapSort即可
inline void heapSort(double arr[], int ptr[], int n)
{
	for (int i = n / 2 - 1; i >= 0; i--)
		heapify(arr, ptr, n, i);

	for (int i = n - 1; i >= 0; i--)
	{
		swap(arr[0], arr[i]);
		swap(ptr[0], ptr[i]);
		heapify(arr, ptr, i, 0);
	}
	return;
}

inline void adjustHeap(double arr[], int ptr[], int n, int i)
{
	int largest = i;
	int left = 2 * i + 1;
	int right = 2 * i + 2;

	if (left < n && arr[left] > arr[largest])
		largest = left;

	if (right < n && arr[right] > arr[largest])
		largest = right;

	if (largest != i)
	{
		swap(arr[i], arr[largest]);
		swap(ptr[i], ptr[largest]);
		adjustHeap(arr, ptr, n, largest);
	}
	return;
}

inline void MCTS_adjustHeap(treeNode* p)
{
	// 在儿子的UCB值更改后，调整堆
	adjustHeap(p->heap_value, p->heap_ptr, p->pos.number, 0);
	return;
}

inline void MCTS_createHeap(treeNode* p)
{
	int child_number = p->pos.number; // 走法个数，使用时下标为0~pos.number-1
	// 传入结点，构建它儿子形成的子堆
	p->heap_value = new double[child_number];
	p->heap_ptr = new int[child_number];
	for (int i = 0; i < child_number; i++)
	{
		p->heap_value[i] = p->child[i]->UCB + RandomNumber(-1000000, 1000000); // 保存儿子UCB
		p->heap_ptr[i] = i;                                                    // 保存下标
	}
	// 建堆，排序
	heapSort(p->heap_value, p->heap_ptr, child_number);
	return;
}

bool MCTS_Play(int simu_color, int(&simuGrid)[8][8])
{
	vector<pair<int, int>> my_chess;
	for (int i = 0; i < GRIDSIZE; i++)
		for (int j = 0; j < GRIDSIZE; j++)
		{
			if (simuGrid[i][j] == simu_color)
			{
				my_chess.push_back(make_pair(i, j));
			}
		}
	int move_chess[4] = { -1, -1, -1, -1 };       // 保存四个棋子中能走的
	int move_dirx[8] = { 0 }, move_diry[8] = { 0 }; // 保存棋子能走的方向
	int xx = 0, yy = 0, xxx = 0, yyy = 0;
	int choose_move_chess = 0;
	int move_chess_cnt = 0;     // 统计可以移动的棋子数量
	int move_dir_cnt = 0;       // 统计可移动的方向
	for (int i = 0; i < 4; i++) // 四个棋子，依次判断是否可以移动
	{
		for (int j = 0; j < 8; j++) // 八个方向，四个棋子只要有一个方向能走就保存在move_chess中，move_chess_cnt统计有几个棋子可移动
		{
			xx = my_chess[i].first + dx[j];
			yy = my_chess[i].second + dy[j];
			if (inMap(xx, yy) && simuGrid[xx][yy] == 0)
				move_dir_cnt++;
		}
		if (move_dir_cnt != 0) // move_dir_cnt不等于零，说明当前棋子可以移动
		{
			move_chess[move_chess_cnt] = i;
			move_chess_cnt++;
		}
		move_dir_cnt = 0;
	}
	if (!move_chess_cnt) // move_chess_cnt=0,说明我方棋子没有可以移动的，直接返回false
		return false;
	choose_move_chess = RandomNumber(0, move_chess_cnt - 1); // 随机选择可移动棋子中的一个
	int x = my_chess[move_chess[choose_move_chess]].first;
	int y = my_chess[move_chess[choose_move_chess]].second;
	move_dir_cnt = 0;
	for (int i = 0; i < 8; i++) // 八个方向，找choose_move_dir棋子能走的方向,保存到move_dirx和move_diry中
	{
		xx = x + dx[i];
		yy = y + dy[i];
		if (inMap(xx, yy) && simuGrid[xx][yy] == 0)
		{
			move_dirx[move_dir_cnt] = dx[i];
			move_diry[move_dir_cnt] = dy[i];
			move_dir_cnt++;
		}
	}
	int choose_dir = RandomNumber(0, move_dir_cnt - 1); // 在能走的方向中随机选择一个
	int step_cnt = 0, choose_step = 0;
	xx = move_dirx[choose_dir] + x;
	yy = move_diry[choose_dir] + y;
	while (inMap(xx, yy) && simuGrid[xx][yy] == 0) // 在这个方向一直走，直至超出地图或者遇到其他棋子/障碍物
	{
		xx += move_dirx[choose_dir];
		yy += move_diry[choose_dir];
		step_cnt++;
	}
	choose_step = RandomNumber(1, step_cnt); // 在能走的步长中随机选择一个，保存为choose_step
	xx = move_dirx[choose_dir] * choose_step + x;
	yy = move_diry[choose_dir] * choose_step + y;
	// 终点位置随机完成
	/*开始随机障碍物*/
	int move_dir_cnt2 = 0;
	for (int i = 0; i < 8; i++) // 在终点位置的八个方向，检查有多少个方向能走
	{
		xxx = xx + dx[i];
		yyy = yy + dy[i];
		if (inMap(xxx, yyy) && ((simuGrid[xxx][yyy] == 0) || (xxx == x && yyy == y)))
		{
			move_dirx[move_dir_cnt2] = dx[i];
			move_diry[move_dir_cnt2] = dy[i];
			move_dir_cnt2++;
		}
	}
	int choose_dir2 = RandomNumber(0, move_dir_cnt2 - 1);
	int step_cnt2 = 0, choose_step2 = 0;
	xxx = xx + move_dirx[choose_dir2];
	yyy = yy + move_diry[choose_dir2];
	while (inMap(xxx, yyy) && (simuGrid[xxx][yyy] == 0 || (xxx == x && yyy == y)))
	{
		xxx += move_dirx[choose_dir2];
		yyy += move_diry[choose_dir2];
		step_cnt2++;
	}
	choose_step2 = RandomNumber(1, step_cnt2);
	// 障碍物随机结束
	xxx = xx + move_dirx[choose_dir2] * choose_step2;
	yyy = yy + move_diry[choose_dir2] * choose_step2;

	simuGrid[x][y] = 0;
	simuGrid[xx][yy] = simu_color;
	simuGrid[xxx][yyy] = OBSTACLE;

	return true;
}

// 用root，生成第i个孩子
inline treeNode* MCTS_born(treeNode* root, int i)
{
	treeNode* p = new treeNode;
	p->father = root; // 保存父亲
	p->move = Move(root->pos.beginPos[i][0], root->pos.beginPos[i][1],
		root->pos.possiblePos[i][0], root->pos.possiblePos[i][1],
		root->pos.obstaclePos[i][0], root->pos.obstaclePos[i][1],
		root->color); // 保存走法
	/*NoCheckStep(root->pos.beginPos[i][0], root->pos.beginPos[i][1],
		root->pos.possiblePos[i][0], root->pos.possiblePos[i][1],
		root->pos.obstaclePos[i][0], root->pos.obstaclePos[i][1],
		root->color);
	p->Sort = maping(calculate());

	Clear(root->pos.beginPos[i][0], root->pos.beginPos[i][1],
		root->pos.possiblePos[i][0], root->pos.possiblePos[i][1],
		root->pos.obstaclePos[i][0], root->pos.obstaclePos[i][1],
		root->color);*/
	p->color = -root->color;     // 颜色反向
	p->depth = root->depth + 1;
	/*if (p->depth > maxdeep)
	{
		maxdeep = p->depth;
	}*/
	return p;                    // 返回新生成的儿子
}

// 根节点初始化，并返回根节点
inline treeNode* MCTS_init()
{
	// 初始化N=0，还没开始搜索
	N = 0;
	// 新建根
	treeNode* root = new treeNode;
	root->color = currBotColor;
	// 把当前棋盘状态给根节点保存
	// 从根节点起，选择UCB最大的子节点
	// 刚开始没有子节点，先生成子节点
	// 传入颜色，和全局的棋盘状态gridInfo[][]
	// 生成所有可能走法，并且返回到root->pos
	// 先生成所有的孩子？

	scan();
	/*vector<pair<int, int>> Info = enclose(root->color);
	if (Info.size() != 0)
	{
		root->pos = enmoveable_Choices(root->color, Info);
	}
	else*/
	root->pos = Choices(root->color);

	// root->pos = Choices(root->color); // 如果生成的pos.number==0，那么已经输了
	for (int i = 0; i < root->pos.number; i++)
	{
		treeNode* p = MCTS_born(root, i);
		root->child[i] = p; // 父亲保存儿子
	}
	sort(root->child, root->child + root->pos.number, cmp);
	root->pos.number = min(root->pos.number, 25);
	// 建堆，每次在扩展的时候（也就是生成子节点之后）
	MCTS_createHeap(root);
	return root;
}

// 传入一个结点，返回他UCB值最大的子节点
// 如果它的子节点UCB值均为INFINITE，返回一个随机值
inline treeNode* MCTS_findMaxUCB(treeNode* root)
{
	// vector<int> inf;
	// int maxUCB = -1;
	// int select = -1;	//最终选择的孩子节点
	// for (int i = 0; i < root->pos.number; i++)
	//{
	//     if (root->child[i]->UCB == INFINITE)
	//     {
	//         inf.push_back(i);
	//         continue;
	//     }
	//     else if (maxUCB < root->child[i]->UCB)
	//     {
	//         maxUCB = root->child[i]->UCB;
	//         select = i;
	//     }
	// }
	////说明所有孩子都没有初始化，那么直接访问一个随机的
	// if (inf.size()==0)
	//     return root->child[select];
	// else
	//{
	//     int select_inf = RandomNumber(0, inf.size() - 1);
	//     return root->child[inf[select_inf]];
	// }
	int i = root->heap_ptr[0];
	return (root->child[i]);
}

double maping(double value)
{
	if (value > 10)
		return 1;
	if (value < -10)
		return 0;
	return (value + 10) / 20.0;
}

inline double Win_Value()
{
	double v = calculate();
	double val = 1.0 / (1 + exp(-v));
	return val;
}

/*inline double MCTS_rollout(treeNode* leaf)
{
	
}*/

// inline void MCTS_clearBoard(treeNode* p)
//{
//     //注意这里应当使用p->move.color而不是p->color
//     return ;
// }

inline void MCTS_updateUCB(treeNode* p)
{
	// 更新UCB值，左值+右值
	// 左值描述历史信息，右值描述可能性

	// 考虑是否有可能root->visit==0
	double left = p->win * 1.0 / p->visit;
	double right;
	if (p->father==root) right=C* sqrt(log(N) / p->visit);
	else right = C * sqrt(log(p->father->visit) / p->visit);
	p->UCB = (p->color==currBotColor)?(left + right):(1-left+right);
	return;
}

inline void MCTS_backPropagate(treeNode* leaf, double result)
{
	if (leaf->father == nullptr)
		return;
	else
	{
		// 有父亲，那么父亲的heap_value要调整
		leaf->father->heap_value[0] = leaf->UCB;
		MCTS_adjustHeap(leaf->father);

		// 调整父亲的UCB访问次数++
		leaf->father->visit++;
		//leaf->father->win += result;
		leaf->father->win_v += result;
		// 更新UCB值
		MCTS_updateUCB(leaf->father);
		// 恢复棋盘状态
		// MCTS_clearBoard(leaf);
		Clear(leaf->move.x, leaf->move.y, leaf->move.xx, leaf->move.yy, leaf->move.xxx, leaf->move.yyy, leaf->move.color);
		// 继续带着结果向上
		MCTS_backPropagate(leaf->father, result);
	}
	return;
}

// bool MCTS_updateBoard(treeNode* p)  //当向下走，走到p结点时，将棋盘状态更新到p结点
//{
//     //注意这里应当使用p->move.color，而不是p->color
//     return ProcStep(p->move.x, p->move.y, p->move.xx, p->move.yy, p->move.xxx, p->move.yyy, p->move.color, false);
// }


//访问次数最多
Move MCTS_selectBest(treeNode* root)
{
	// double maxRate = -1;
	int visitMax = -1;
	int select = -1;
	for (int i = 0; i < root->pos.number; i++)
	{
		// 如果一次都没访问过，就略过
		//if (root->child[i]->visit == 0)
		//	continue;
		//double winRate = root->child[i]->win * 1.0 / root->child[i]->visit;
		
		if (visitMax < root->child[i]->visit)
		{
			//visitS = root->child[i]->visit;
			visitMax= root->child[i]->visit;
			select = i;
		}
	}
	Move move = root->child[select]->move;
	// 如果一个都选不出来，直接输了，不处理，浪费时间
	return move;
}

void MCTS_main(treeNode* root)
{
	N++;
	// 每调用一次该函数，相当于进行一次rollout

	// 从根节点开始，选择一个UCB最大的子节点，直到遇到叶子节点
	// 子节点保存在root->child[]
	treeNode* p = root;
	// 可以通过某结点node的 node->pos.number来判断是否为叶子节点
	// 如果为叶子节点，无孩子，所以pos.number初值为-1
	// 但叶子节点可能访问过，即rollout过
	// 注意区分终局，如果已经完全无法走动，那么pos.number=0
	//
	// 否则就是已经扩展了儿子走法

	// 当还没走到叶子节点
	while (p->pos.number != -1)
	{
		if (p->pos.number == 0)
		{
			p->visit++;
			if (p->color == -currBotColor)
			{
				//p->win++;
				p->win_v += 1;
				MCTS_updateUCB(p);
				MCTS_backPropagate(p, WIN);
			}
			else
			{
				MCTS_updateUCB(p);
				MCTS_backPropagate(p, LOSE);
			}
			return;
		}

		if (p->selected_ch.size() < p->pos.number) //如果还未完全扩展
		{
			int select = RandomNumber(p->selected_ch.size() + 1, p->pos.number); //随机找儿子
			treeNode* new_ch = MCTS_born(p, select);
			p->selected_ch.push_back(new_ch);

			NoCheckStep(new_ch->move.x, new_ch->move.y, new_ch->move.xx, new_ch->move.yy, new_ch->move.xxx, new_ch->move.yyy, new_ch->color);
			double result = Win_Value();
			new_ch->win_v += result;
			Clear(new_ch->move.x, new_ch->move.y, new_ch->move.xx, new_ch->move.yy, new_ch->move.xxx, new_ch->move.yyy, new_ch->color);

			MCTS_backPropagate(new_ch, result);

			swap(p->child[p->selected_ch.size()], p->child[select]); //交换
		}
		else
		{

		}

		// 选出一个子节点
		p = MCTS_findMaxUCB(p);
		// 更新棋盘状态
		// MCTS_updateBoard(p);
		// ProcStep(p->move.x, p->move.y, p->move.xx, p->move.yy, p->move.xxx, p->move.yyy, p->move.color, false);
		// 这里的棋步都不需要检测
		NoCheckStep(p->move.x, p->move.y, p->move.xx, p->move.yy, p->move.xxx, p->move.yyy, p->move.color);
	}
	// 走到了叶节点p

	// 若叶子节点未被访问(visit==0),rollout该节点
	// 否则就扩展该节点，并任选一个子节点rollout
	if (!p->visit)
	{
		double result = MCTS_rollout(p); // 从p结点开始rollout
		p->visit++;
		p->win += result;
		// 更新该节点的UCB值
		MCTS_updateUCB(p);
		// rollout后回溯到顶层，注意：回溯过程中复原了棋盘
		MCTS_backPropagate(p, result);
	}
	else
	{
		if (p->depth >= 5)
		{

			double re = maping(calculate());
			p->win += re;
			p->visit++;
			MCTS_updateUCB(p);
			MCTS_backPropagate(p, re);
			return;
		}
		// 扩展子节点
		// 也有可能无法扩展，即pos.number返回为0，待考虑
		//
		// 获取p结点的所有走法，如果是0，就不会进入
		scan();
		/*vector<pair<int, int>> Info = enclose(p->color);
		if (Info.size() != 0)
		{
			p->pos = enmoveable_Choices(p->color,Info);
		}
		else*/
		p->pos = Choices(p->color);
		for (int i = 0; i < p->pos.number; i++)
		{
			treeNode* chd = MCTS_born(p, i);
			p->child[i] = chd;
#ifdef TIME_CONTROL
			current_time = clock();
			loop_out_time = current_time - start_time;
			// 开局时间翻倍
			double threshold_temp = turnID == 1 ? MCTS_time * 2 : MCTS_time;
			if (loop_out_time > threshold_temp)
			{
				// 时间超了
				time_out = true;
				return;
			}
#endif
		}
		// 扩展完成，先判断是否已经没有子节点能走了
		if (p->pos.number == 0)
		{
			p->visit++;
			if (p->color == currBotColor)
			{
				// 输的情况
				MCTS_updateUCB(p);
				MCTS_backPropagate(p, LOSE);
			}
			else
			{
				// 赢的情况
				p->win += 1;
				MCTS_updateUCB(p);
				MCTS_backPropagate(p, WIN);
			}
			return;
		}

		sort(p->child, p->child + p->pos.number, cmp);
		p->pos.number = min(p->pos.number, 25);
		// 任选一个子节点rollout
		// 直接选一个UCB最大的就行
		MCTS_createHeap(p);
		treeNode* select = MCTS_findMaxUCB(p);
		// rollout前，先使棋盘状态变为其子节点的状态
		// MCTS_updateBoard(p->child[select]);
		NoCheckStep(select->move.x, select->move.y, select->move.xx, select->move.yy, select->move.xxx, select->move.yyy, select->move.color);
		// rollout
		double result = MCTS_rollout(select);
		select->visit++;
		select->win += result;
		MCTS_updateUCB(select);
		// 更新该节点的UCB后，其父亲的UCB也应当更新。其父亲中存储的p->heap_value[0]应当置为新的儿子UCB，且重新调整堆
		MCTS_backPropagate(select, result);
		// rollout以后回溯到顶层
	}
	return;
}

/*******************************************************************************************************************/

/*******************************************************************************************************************/
// 评估函数
// m的计算，代表最终的灵活度
inline double m(int color)
{
	double tmp = 0;
	for (int i = 0; i < GRIDSIZE; i++)
	{
		for (int j = 0; j < GRIDSIZE; j++)
		{
			if (gridInfo[i][j] == currBotColor)
			{
				double sum = 0;
				for (int k = 0; k < 8; k++) // 8个方向
					for (int step = 1; step < GRIDSIZE; step++)
					{
						int tmpx = i + dx[k] * step;
						int tmpy = j + dy[k] * step;
						if (gridInfo[tmpx][tmpy] != 0 || !inMap(tmpx, tmpy))
							break;
						sum += mobility[tmpx][tmpy] / step;
					}
				tmp -= 100.0 / (10 + sum);
			}
			if (gridInfo[i][j] == -currBotColor)
			{
				double sum = 0;
				for (int k = 0; k < 8; k++) // 8个方向
					for (int step = 1; step < GRIDSIZE; step++)
					{
						int tmpx = i + dx[k] * step;
						int tmpy = j + dy[k] * step;
						if (gridInfo[tmpx][tmpy] != 0 || !inMap(tmpx, tmpy))
							break;
						sum += mobility[tmpx][tmpy] / step;
					}
				tmp += 100.0 / (10 + sum);
			}
		}
	}
	return tmp;
}
// c2的计算，代表King走法的地理优势
inline double c2()
{
	double c_2 = 0;
	for (int i = 0; i < GRIDSIZE; i++)
		for (int j = 0; j < GRIDSIZE; j++)
		{
			if (D1[0][i][j] != 100 && D1[1][i][j] != 100)
			{
				double tem = (D2[1][i][j] - D2[0][i][j]) / 6.0;
				if (tem < -1)
				{
					c_2 -= 1.0;
				}
				else if (tem >= -1 && tem <= 1)
				{
					c_2 += tem;
				}
				else
				{
					c_2 += 1.0;
				}
			}
		}
	return c_2;
}
// c1的计算，代表Queen走法的地理优势
inline double c1()
{
	double c_1 = 0;
	for (int i = 0; i < GRIDSIZE; i++)
		for (int j = 0; j < GRIDSIZE; j++)
		{
			if (D1[0][i][j] != 100 && D1[1][i][j] != 100)
				c_1 += pow(2, -D1[0][i][j]) - pow(2, -D1[1][i][j]);
		}
	return 2 * c_1;
}
// t2的计算，代表King走法对空格的控制权
inline double t2(int color)
{
	double tem = 0;
	{
		for (int i = 0; i < GRIDSIZE; i++)
		{
			for (int j = 0; j < GRIDSIZE; j++)
			{
				if (D2[1][i][j] > D2[0][i][j])
				{
					tem += 1;
				}
				else if (D2[1][i][j] < D2[0][i][j])
				{
					tem -= 1;
				}
				else // 步数相等
				{
					if (D2[0][i][j] < 100) // 都能到
					{
						if (color == currBotColor)
							tem += 0.1;
						else
							tem -= 0.1;
					}
				}
			}
		}
	}
	return tem;
}
// t1的计算，代表Queen走法对空格的控制权
inline double t1(int color)
{
	double tem = 0;
	{
		for (int i = 0; i < GRIDSIZE; i++)
		{
			for (int j = 0; j < GRIDSIZE; j++)
			{
				if (D1[1][i][j] > D1[0][i][j])
				{
					tem += 1;
				}
				else if (D1[1][i][j] < D1[0][i][j])
				{
					tem -= 1;
				}
				else // 步数相等
				{
					if (D1[0][i][j] < 100) // 都能到
					{
						if (color == currBotColor)
							tem += 0.1;
						else
							tem -= 0.1;
					}
				}
			}
		}
	}
	return tem;
}
// 查看这个颜色的棋子，在这盘局面下拥有的价值。三阶段下权重不同
inline double value(int color)
{
#ifdef PARA
	cout << t1(color) << "   " << t2(color) << "   " << c1() << "   " << c2() << "   " << m(color) << endl;
#endif
	return f1[turnID] * t1(color) + f2[turnID] * t2(color) + f3[turnID] * c1() + f4[turnID] * c2() + f5[turnID] * m(color);
}
// 存下来灵活度
inline void moble()
{
	for (int i = 0; i < GRIDSIZE; i++)
		for (int j = 0; j < GRIDSIZE; j++) // ij位上的棋子灵活度
		{
			if (gridInfo[i][j] != 0)
				continue; // 如果不是空格就算了
			for (int try1 = 0; try1 < 8; try1++)
			{
				int xx = i + dx[try1];
				int yy = j + dy[try1];
				if (inMap(xx, yy) && gridInfo[xx][yy] == 0)
				{
					mobility[i][j]++; // 它周围的八个位置如果是空格，它的价值就升高
				}
			}
		}
}
inline void clear(queue<Coor>& q) {
	queue<Coor> empty;
	swap(empty, q);
}
inline vector<pair<int, int>> enclose(int color)
{
	// scan();
	queue<Coor> q;
	vector<pair<int, int>> my_movable_chess;
	int visit[GRIDSIZE][GRIDSIZE];
	for (int i = 0; i < GRIDSIZE; i++)
		for (int j = 0; j < GRIDSIZE; j++)
			visit[i][j] = gridInfo[i][j];
	if (color == grid_black) // 读入棋子的位置
	{
		for (int i = 0; i < 4; i++)
		{
			bool flag = false;
			q.push(Coor(blackInfo[i].first, blackInfo[i].second, 0));
			while (!q.empty() && !flag)
			{
				Coor coor = q.front();
				q.pop();
				visit[coor.x][coor.y] = OBSTACLE;
				for (int dir = 0; dir < 8 && !flag; dir++)
				{
					int tryx = coor.x + dx[dir];
					int tryy = coor.y + dy[dir];
					if (!inMap(tryx, tryy))
						continue;
					if (visit[tryx][tryy] == OBSTACLE || visit[tryx][tryy] == color)
					{
						continue;
					}
					if (visit[tryx][tryy] == -color)
					{
						flag = true;
						for (int k = 0; k < GRIDSIZE; k++)
						{
							int xx = coor.x + dx[k];
							int yy = coor.y + dy[k];
							if (inMap(xx, yy) && gridInfo[xx][yy] == 0)
							{
								my_movable_chess.push_back(blackInfo[i]);
								clear(q);
								break;
							}
						}
					} // end of if
					q.push(Coor(tryx, tryy, 0));
				}// end of for
			}// end of while
		} // end of for
	}
	else
	{
		for (int i = 0; i < 4; i++)
		{
			bool flag = false;
			q.push(Coor(whiteInfo[i].first, whiteInfo[i].second, 0));
			while (!q.empty() && !flag)
			{
				Coor coor = q.front();
				q.pop();
				visit[coor.x][coor.y] = OBSTACLE;
				for (int dir = 0; dir < 8 && !flag; dir++)
				{
					int tryx = coor.x + dx[dir];
					int tryy = coor.y + dy[dir];
					if (!inMap(tryx, tryy))
						continue;
					if (visit[tryx][tryy] == OBSTACLE || visit[tryx][tryy] == color)
					{
						continue;
					}
					if (visit[tryx][tryy] == -color)
					{
						flag = true;
						for (int k = 0; k < GRIDSIZE; k++)
						{
							int xx = coor.x + dx[k];
							int yy = coor.y + dy[k];
							if (inMap(xx, yy) && gridInfo[xx][yy] == 0)
							{
								my_movable_chess.push_back(whiteInfo[i]);
								clear(q);
								break;
							}
						}
					} // end of if
					q.push(Coor(tryx, tryy, 0));
				}
			}
			// end of while
		} // end of for
	}
	return my_movable_chess; // vector<pair<int,int>>
	// for (int i=0;i<=my_movable_chess.size();i++)
}
// 计算所有Queen和King走法，保存在D1，D2中
inline void movevalue(int color)
{

	queue<Coor> qQueen, qKing;
	if (color == grid_black) // 读入棋子的位置
	{
		for (int i = 0; i < 4; i++)
		{
			qQueen.push(Coor(blackInfo[i].first, blackInfo[i].second, 0));
			qKing.push(Coor(blackInfo[i].first, blackInfo[i].second, 0));
		}
	}
	else
	{
		for (int i = 0; i < 4; i++)
		{
			qQueen.push(Coor(whiteInfo[i].first, whiteInfo[i].second, 0));
			qKing.push(Coor(whiteInfo[i].first, whiteInfo[i].second, 0));
		}
	}
	int div = color == currBotColor ? 0 : 1;
	// 处理皇后走法，赋值给D1
	while (!qQueen.empty())
	{
		Coor pos = qQueen.front();
		qQueen.pop();
		for (int i = 0; i < 8; i++) // 方向
		{
			for (int k = 1; k < GRIDSIZE; k++)
			{
				int tempx = dx[i] * k + pos.x;
				int tempy = dy[i] * k + pos.y;
				// 不在地图内部，或不是空格，就退出
				if (!inMap(tempx, tempy) || gridInfo[tempx][tempy] != 0)
					break;
				if (pos.val + 1 < D1[div][tempx][tempy])
				{
					D1[div][tempx][tempy] = pos.val + 1;
					qQueen.push(Coor(tempx, tempy, pos.val + 1));
				}
			}
		}
	}
	// 处理国王走法，赋值给D2
	while (!qKing.empty())
	{
		Coor pos = qKing.front();
		qKing.pop();
		for (int i = 0; i < 8; i++) // 方向
		{
			int tempx = dx[i] + pos.x;
			int tempy = dy[i] + pos.y;
			// 不在地图内部，或不是空格，就退出
			if (!inMap(tempx, tempy) || gridInfo[tempx][tempy] != 0)
				continue;
			if (pos.val + 1 < D2[div][tempx][tempy])
			{
				D2[div][tempx][tempy] = pos.val + 1;
				qKing.push(Coor(tempx, tempy, pos.val + 1));
			}
		}
	}
}

void initializeD() // 用于初始化D1/D2数组
{
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (gridInfo[i][j] == 0)
			{
				D1[0][i][j] = D1[1][i][j] = D2[0][i][j] = D2[1][i][j] = 100;
			}
			else if (gridInfo[i][j] == currBotColor)
			{
				D1[1][i][j] = D2[1][i][j] = -1;
				D1[0][i][j] = D2[0][i][j] = 0;
			}
			else if (gridInfo[i][j] == -currBotColor)
			{
				D1[0][i][j] = D2[0][i][j] = -1;
				D1[1][i][j] = D2[1][i][j] = 0;
			}
			else
			{
				D1[0][i][j] = D2[0][i][j] = D1[1][i][j] = D2[1][i][j] = -1;
			}
		}
	}
}
inline double calculate()
{
	scan();                                // 存状态
	memset(mobility, 0, sizeof(mobility)); // 清零灵活度数组
	initializeD();
	/*计算所有Queen和King走法，保存在D1，D2中*/
	movevalue(currBotColor);
	movevalue(-currBotColor);
	moble();                            // 存下来灵活度
	double Value = value(currBotColor); // 查看这个颜色的棋子，在这盘局面下拥有的价值。三阶段下权重不同
	return Value;
}
/*******************************************极大极小搜索*******************************************/
// 回溯一回合某方的行动
inline void Clear(int x0, int y0, int x1, int y1, int x2, int y2, int color)
{
	gridInfo[x2][y2] = 0;
	gridInfo[x1][y1] = 0;
	gridInfo[x0][y0] = color;
}
// 找出当前所有可能走法,返回走法数
Pos Choices(int color)
{
	/*blackInfo.clear();
	whiteInfo.clear();
	arrowInfo.clear();
	scan();*/
	Pos pos;
	int posCount = 0;
	vector<pair<int, int>>* Info[2];
	Info[0] = &blackInfo, Info[1] = &whiteInfo;
	int div = -1;
	div = color == grid_black ? 0 : 1; // 0代表黑子，1代表白子
	for (int i = 0; i < 4; i++)
		for (int j = 0; j < 8; j++)
		{
			for (int try1 = 1; try1 < GRIDSIZE; try1++)
			{
				// 尝试终点位置
				int xx = dx[j] * try1 + (*Info[div])[i].first;
				int yy = dy[j] * try1 + (*Info[div])[i].second;
				if (!inMap(xx, yy) || gridInfo[xx][yy] != 0)
					break;
				// 寻找障碍物的位置
				for (int k = 0; k < 8; k++)
					for (int try2 = 1; try2 < GRIDSIZE; try2++)
					{
						int xxx = xx + dx[k] * try2;
						int yyy = yy + dy[k] * try2;
						if ((!inMap(xxx, yyy)) || (gridInfo[xxx][yyy] != 0 && !((*Info[div])[i].first == xxx && (*Info[div])[i].second == yyy)))
							break;
						if (ProcStep((*Info[div])[i].first, (*Info[div])[i].second, xx, yy, xxx, yyy, color, true))
						{
							pos.beginPos[posCount][0] = (*Info[div])[i].first;
							pos.beginPos[posCount][1] = (*Info[div])[i].second;
							pos.possiblePos[posCount][0] = xx;
							pos.possiblePos[posCount][1] = yy;
							pos.obstaclePos[posCount][0] = xxx;
							pos.obstaclePos[posCount++][1] = yyy;
						}
					}
			}
		}
	pos.number = posCount;

	blackInfo.clear();
	whiteInfo.clear();
	arrowInfo.clear();

	// 清空记录的数组
	return pos;
}

Pos enmoveable_Choices(int color, vector<pair<int, int>> Info)
{
	Pos pos;
	int posCount = 0;
	int end = Info.size();
	for (int i = 0; i < end; i++)
		for (int j = 0; j < 8; j++)
		{
			for (int try1 = 1; try1 < GRIDSIZE; try1++)
			{
				// 尝试终点位置
				int xx = dx[j] * try1 + Info[i].first;
				int yy = dy[j] * try1 + Info[i].second;
				if (!inMap(xx, yy) || gridInfo[xx][yy] != 0)
					break;
				// 寻找障碍物的位置
				for (int k = 0; k < 8; k++)
					for (int try2 = 1; try2 < GRIDSIZE; try2++)
					{
						int xxx = xx + dx[k] * try2;
						int yyy = yy + dy[k] * try2;
						if ((!inMap(xxx, yyy)) || (gridInfo[xxx][yyy] != 0 && !(Info[i].first == xxx && Info[i].second == yyy)))
							break;
						if (ProcStep(Info[i].first, Info[i].second, xx, yy, xxx, yyy, color, true))
						{
							pos.beginPos[posCount][0] = Info[i].first;
							pos.beginPos[posCount][1] = Info[i].second;
							pos.possiblePos[posCount][0] = xx;
							pos.possiblePos[posCount][1] = yy;
							pos.obstaclePos[posCount][0] = xxx;
							pos.obstaclePos[posCount++][1] = yyy;
						}
					}
			}
		}
	pos.number = posCount;
	return pos;
}
// 负极大极小搜索，a-b剪枝，初始alpha为负无穷，beta为正无穷
double Max_Min_Search(int depth, int now_depth, double alpha, double beta, int now_color)
{
#ifdef TIME_CONTROL
	current_time = clock();
	loop_out_time = current_time - start_time;
	// 开局时间翻倍
	double threshold_temp = (turnID == 1) ? threshold * 2 : threshold;
	// cout << "loop_out_time=" << loop_out_time << "      threshold_tmp=" << threshold_temp<<endl;
	if (loop_out_time > threshold_temp)
	{
		// 时间超了
		time_out = true;
		return 0;
	}
#endif
	if (now_depth == depth) // 到达层数评估当前棋盘
	{
		int sign = now_depth % 2 == 0 ? 1 : -1;
		double x = sign * calculate();
		/* cout << "当前回合：" << turnID << "   评估值：" << sign*x<< endl;
		 all++;
		 if (sign*x > 10)
			 ten++;
		 if (sign*x<10 && sign*x > 9)
			 a9++;
		 if (sign*x < 9 && sign*x > 8)
			 a8++;
		 if (sign*x < 8 && sign*x > 7)
			 a7++;
		 if (sign*x < 7 && sign*x > 6)
			 a6++;
		 if (sign*x < 6 && sign*x > 5)
			 a5++;
		 if (sign*x < 5 && sign*x > 4)
			 a4++;
		 if (sign*x < 4 && sign*x > 3)
			 a3++;
		 if (sign*x < 3 && sign*x > 2)
			 a2++;
		 if (sign*x < 2 && sign*x > 1)
			 a1++;
		 if (sign*x < 1 && sign*x > 0)
			 a0++;
		 if (sign * x < 0)
			 a10++;*/
		return x;
	}
	Pos pos;
	scan();
	//vector<pair<int, int>> Info = enclose(now_color);
	//if (Info.size() != 0)
	//{
	// pos = enmoveable_Choices(now_color, Info);
	//}
	//else
	//{
	pos = Choices(now_color);
	//}
	if (pos.number == 0)
	{
		int sign = now_depth % 2 == 0 ? 1 : -1;
		double x = sign * calculate();
		return x;
	}

	double val = 0;
	int choose = 0; // choose需要初值吗？待考虑！
	for (int i = 0; i < pos.number; i++)
	{
		if (loop_out_time > threshold_temp)
		{
			// 时间超了
			time_out = true;
			return 0;
		}
		int x0, y0, x1, y1, x2, y2;

		// 落子，由于现在不可能走非法棋步，所以改为NoCheckStep
		// if (!ProcStep(pos.beginPos[i][0], pos.beginPos[i][1], pos.possiblePos[i][0], pos.possiblePos[i][1], pos.obstaclePos[i][0], pos.obstaclePos[i][1], now_color, false))
		//{
		//    cout << "fail in procstep" << endl;
		//    getchar();
		//}
		NoCheckStep(pos.beginPos[i][0], pos.beginPos[i][1], pos.possiblePos[i][0], pos.possiblePos[i][1], pos.obstaclePos[i][0], pos.obstaclePos[i][1], now_color);

		x0 = pos.beginPos[i][0];
		y0 = pos.beginPos[i][1];
		x1 = pos.possiblePos[i][0];
		y1 = pos.possiblePos[i][1];
		x2 = pos.obstaclePos[i][0];
		y2 = pos.obstaclePos[i][1];

		val = -Max_Min_Search(depth, now_depth + 1, -beta, -alpha, -now_color); // 返回负，从而可以将每层都看作Max层

		// 回溯
		Clear(x0, y0, x1, y1, x2, y2, now_color);

		if (val >= beta)
		{
			return beta; // beta剪枝
		}

		if (val > alpha)
		{
			alpha = val;
			choose = i; // 目前第i种落子最好
		}
	}

#ifdef TIME_CONTROL
	current_time = clock();
	loop_out_time = current_time - start_time;
	// 开局时间翻倍
	threshold_temp = (turnID == 1) ? threshold * 2 : threshold;
	if (loop_out_time > threshold_temp)
	{
		// 时间超了
		time_out = true;
		return 0;
	}
#endif

	if (now_depth == 0 && !time_out) // 如果当前为根则保存最佳走法
	{
		startX = pos.beginPos[choose][0];
		startY = pos.beginPos[choose][1];
		resultX = pos.possiblePos[choose][0];
		resultY = pos.possiblePos[choose][1];
		obstacleX = pos.obstaclePos[choose][0];
		obstacleY = pos.obstaclePos[choose][1];
	}

	return alpha;
}
int main()
{
	/**************************************************************************************************/
	int x0, y0, x1, y1, x2, y2;

	// 初始化棋盘
	gridInfo[0][2] = grid_black;
	gridInfo[2][0] = grid_black;
	gridInfo[5][0] = grid_black;
	gridInfo[7][2] = grid_black;

	gridInfo[0][5] = grid_white;
	gridInfo[2][7] = grid_white;
	gridInfo[5][7] = grid_white;
	gridInfo[7][5] = grid_white;

	// 分析自己收到的输入和自己过往的输出，并恢复棋盘状态

	cin >> turnID;

	currBotColor = grid_white; // 先假设自己是白方
	for (int i = 0; i < turnID; i++)
	{
		// 根据这些输入输出逐渐恢复状态到当前回合

		// 首先是对手行动
		cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2;
		if (x0 == -1)
			currBotColor = grid_black; // 第一回合收到坐标是-1, -1，说明我方是黑方
		else
			ProcStep(x0, y0, x1, y1, x2, y2, -currBotColor, false); // 模拟对方落子

		// 然后是本方当时的行动
		// 对手行动总比自己行动多一个
		if (i < turnID - 1)
		{
			cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2;
			if (x0 >= 0)
				ProcStep(x0, y0, x1, y1, x2, y2, currBotColor, false); // 模拟本方落子
		}
	}
	/*****************************************************************************************************/

#ifdef TIME_CONTROL
	start_time = clock();
#endif


	// 这里使用蒙特卡洛搜索树
	if (turnID >= 10)
	{
		root = MCTS_init();
		while (!time_out)
		{
			if (turnID < 12) C = 0.01 * turnID;									// 动态调整C
			else C = 0.3;
			MCTS_main(root);
#ifdef TIME_CONTROL
			current_time = clock();
			loop_out_time = current_time - start_time;
			// 开局时间翻倍
			double threshold_temp = turnID == 1 ? MCTS_time * 2 : MCTS_time;
			if (loop_out_time > threshold_temp)
			{
				// 时间超了
				time_out = true;
				break;
			}
#endif
		}
		// 时间快到了，出来赋值
		Move move = MCTS_selectBest(root);
		startX = move.x;
		startY = move.y;
		resultX = move.xx;
		resultY = move.yy;
		obstacleX = move.xxx;
		obstacleY = move.yyy;
		double loop_out_sec = loop_out_time * 1.0 / A_SEC;
		int out_time = clock();
		double out_sec = (out_time - start_time) * 1.0 / A_SEC;
		cout << startX << ' ' << startY << ' ' << resultX << ' ' << resultY << ' ' << obstacleX << ' ' << obstacleY << endl;
		cout << "循环退出用时 = " << loop_out_sec << " 总用时 out_time = " << out_sec << " 总模拟次数 N = " << N << " 胜率最大 maxRate = " << maxRate << " 访问次数 visitS = " << visitS << " turnID = " << turnID << endl;
		cout << "采用蒙特卡洛搜索树" << endl;
		cout << "最大深度" << maxdeep << "   儿子输  " << root->pos.number << endl;
	}
	else
	{
		// 后边是极大极小搜索
		//  这里理论上可以无穷层
		int depth = 1;
		for (depth = 1; depth <= INFINITE; depth++)
		{
			Max_Min_Search(depth, 0, -INFINITE, INFINITE, currBotColor);
#ifdef TIME_CONTROL
			if (time_out)
				break;
#endif
		}
		out_time = clock();
		double loop_out_sec = loop_out_time * 1.0 / A_SEC;
		double out_sec = (out_time - start_time) * 1.0 / A_SEC;
		cout << startX << ' ' << startY << ' ' << resultX << ' ' << resultY << ' ' << obstacleX << ' ' << obstacleY << endl;
		cout << "循环退出用时 = " << loop_out_sec << " 总用时 out_time = " << out_sec << endl;//" root->pos.number = " << root->pos.number << " Max_min_search_valid depth = " << depth << endl;
		cout << "valid depth = " << depth << endl;
		cout << "采用极大极小" << endl;
	}

	// 下面的代码暂时没用
	cout << "共评估" << all << "次   ，大于10：" << ten << "次" << a9 << "   " << a8 << "   " << a7 << "   " << a6 << "   " << a5 << "   " << a4 << "   " << a3 << "   " << a2 << "   " << a1 << "   " << a0 << "   " << a10 << endl;
	return 0;
}